<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>原进榜的博客</title>
		<link rel="stylesheet" href="./css/bootstrap.css" >
		<script src="./js/jquery-3.1.1.min.js"></script>
		<script src="/js/bootstrap.min.js"></script>
		<style>
			
			
			#title{width:100%; height:200px; background:#ccc;}
			#ss{font-size:42px; top:60px; position:absolute; left:80px;}
			.form-group{position:absolute; left:700px; top:80px;}
			.container{width:100%;}
			.navbar-nav{margin-left:80px;}
			.navbar-nav li{margin-left:50px;}
			.column{margin-left:50px; border:1px solid #ddd;}
			#cont{background:#ccc;}
			/*#title{
				width:100%;
				height:200px;
				background:#ccc;


			}

			.container{
				width:100%;
			}*/
			#wz{
				font-size:20px;
				color:#abc;
				position:absolute;
				top:110px;
				left:80px;
			
			}

			
		</style>
	</head>
	<body>
	
		<div class="container">
			<div class="row clearfix">
				<div id="title">
					<span id="ss">Benson的博客</span>
					<span id="wz">http://www.yuanjinbang.cn</span>
					<form class="navbar-form navbar-left" role="search">
						<div class="form-group">
							<input class="form-control" type="text" />
							<button type="submit" class="btn btn-default">搜索</button>
						</div>
					</form>
				</div>
			</div>
		</div>


		<div class="container">
			<div class="row clearfix">
					<nav class="navbar navbar-default" role="navigation">
						<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1" >
							<ul class="nav navbar-nav">
								<li class="active">
									 <a href="./index.html">首页</a>
								</li>
								<li>
									 <a href="./phpbase.html">PHP</a>
								</li>
								<li>
									 <a href="./master.html">日常八卦</a>
								</li>
								<li>
									 <a href="#">杂志</a>
								</li>
								<li>
									 <a href="#">git</a>
								</li>
								<li>
									 <a href="#">工具</a>
								</li>
								<li>
									 <a href="./zt.html">杂谈</a>
								</li>
							</ul>
						</div>
					</nav>
			</div>
			<div class="row clearfix" >
				<div class="col-md-7 column">
					<div class="card" id="name1">
						<h2>MyIsam和InnoDB的优缺点</h2>
							<p><h4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作者：原进榜   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 时间:2016年11月25日</h4></p>  
							
						<div id="cont">
							<code>
								<pre>
	InnoDB:	　
	　　InnoDB 给 MySQL 提供了具有事务(commit)、回滚(rollback)和崩溃修复能力

	　　(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。InnoDB 提供了行锁
	　　(locking on row level)，提供与 Oracle 类型一致的不加锁读取(non-lockingread in SELECTs)    
	   。这些特性均提高了多用户并发操作的性能表现。

	　　在InnoDB表中不需要扩大锁定(lock escalation)，因为 InnoDB 的列锁定(row level
	　　locks)适宜非常小的空间。InnoDB 是 MySQL 上第一个提供外键约束(FOREIGN KEY
	　　constraints)的表引擎。
	　　
	　　InnoDB 的设计目标是处理大容量数据库系统，它的 CPU 利用率是其它基于磁盘的关系数据库
	　　引擎所不能比的。在技术上，InnoDB 是一套放在 MySQL 后台的完整数据库系统，
	　　InnoDB 在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。 InnoDB 把数据和索引存
	　　放在表空间里，可能包含多个文件，这与其它的不一样，举例来说，在 MyISAM 中，表被存放
	　　在单独的文件中。InnoDB 表的大小只受限于操作系统的文件大小，一般为 2 GB。
	　　InnoDB所有的表都保存在同一个数据文件 ibdata1 中（也可能是多个文件，或者是独立的
	　　表空间文件）,相对来说比较不好备份，免费的方案可以是拷贝数据文件、备份 binlog，
	　　或者用 mysqldump。
　　
　　MyISAM
	　　MyISAM 是MySQL缺省存贮引擎 .
	　　
	　　每张MyISAM 表被存放在三个文件 。frm 文件存放表格定义。 数据文件是MYD (MYData) 。
	　　索引文件是MYI (MYIndex) 引伸。
	　　
	　　因为MyISAM相对简单所以在效率上要优于InnoDB..小型应用使用MyISAM是不错的选择.
	　　
	　　MyISAM表是保存成文件的形式,在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦
	　　
	　　MyISAM是ISAM表的新版本，有如下扩展：
	　　
	　　·二进制层次的可移植性。
	　　·NULL列索引。
	　　·对变长行比ISAM表有更少的碎片。
	　　·支持大文件。
	　　·更好的索引压缩。
	　　·更好的键吗统计分布。
	　　·更好和更快的auto_increment处理。
　　
　　以下是一些细节和具体实现的差别：
　　
　　◆1.InnoDB不支持FULLTEXT类型的索引。
　　◆2.InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，
　　InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。
　　注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的。
　　◆3.对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM
　　表中，可以和其他字段一起建立联合索引。
　　◆4.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。
　　◆5.LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成
　　MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性（例如外键）的
　　表不适用。
　　
　　◆MyISAM类型的二进制数据文件可以在不同操作系统中迁移。
　　
　　另外，InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的
　　范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”
　　
　　再另外，使用两种的选择：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，
　　应该使用InnoDB表。如果执行大量的SELECT，MyISAM是更好的选择。若需要使用事务处理，
　　但是原来的数据表使用的是myisam，就需要改为bdb或者innodb，这样基于myisam的程序，
　　将类型改为innodb后，其程序不用改动……
　　
　　综上所述，任何一种表都不是万能的，只有恰当的针对业务类型来选择合适的表类型，才能
　　最大的发挥MySQL的性能优势。
　　
　　MyISAM和InnoDB优化：
　　key_buffer_size - 这对MyISAM表来说非常重要。如果只是使用MyISAM表，可以把它设置
　　为可用内存的 30-40%。合理的值取决于索引大小、数据量以及负载 -- 记住，MyISAM表会
　　使用操作系统的缓存来缓存数据，因此需要留出部分内存给它们，很多情况下数据比索引大
　　多了。尽管如此，需要总是检查是否所有的 key_buffer 都被利用了 -- .MYI 文件只有 1GB
　　，而 key_buffer 却设置为 4GB 的情况是非常少的。这么做太浪费了。如果你很少使用
　　MyISAM表，那么也保留低于 16-32MB 的 key_buffer_size 以适应给予磁盘的临时表索引
　　所需。

　　innodb_buffer_pool_size - 这对Innodb表来说非常重要。Innodb相比MyISAM表对缓冲更
　　为敏感。MyISAM可以在默认的 key_buffer_size 设置下运行的可以，然而Innodb在默认的
　　innodb_buffer_pool_size 设置下却跟蜗牛似的。由于Innodb把数据和索引都缓存起来，
　　无需留给操作系统太多的内存，因此如果只需要用Innodb的话则可以设置它高达 70-80% 的
　　可用内存。一些应用于 key_buffer 的规则有 -- 如果你的数据量不大，并且不会暴增，那
　　么无需把innodb_additional_pool_size - 这个选项对性能影响并不太多，至少在有差不多足够内存
　　可分配的操作系统上是这样。不过如果你仍然想设置为 20MB(或者更大)，因此就需要看一下
　　Innodb其他需要分配的内存有多少。

　　innodb_log_file_size 在高写入负载尤其是大数据集的情况下很重要。这个值越大则性能相
　　对越高，但是要注意到可能会增加恢复时间。我经常设置为 64-512MB，跟据服务器大小而异。
　　innodb_log_buffer_size 默认的设置在中等强度写入负载以及较短事务的情况下，服务器性
　　能还可以。如果存在更新操作峰值或者负载较大，就应该考虑加大它的值了。如果它的值设置
　　太高了，可能会浪费内存 -- 它每秒都会刷新一次，因此无需设置超过1秒所需的内存空间。
　　通常 8-16MB 就足够了。越小的系统它的值越小。

　　innodb_flush_logs_at_trx_commit 是否为Innodb比MyISAM慢1000倍而头大？看来也许你忘
　　了修改这个参数了。默认值是 1，这意味着每次提交的更新事务（或者每个事务之外的语句）
　　都会刷新到磁盘中，而这相当耗费资源，尤其是没有电池备用缓存时。很多应用程序，尤其是
　　从 MyISAM转变过来的那些，把它的值设置为 2 就可以了，也就是不把日志刷新到磁盘上，
　　而只刷新到操作系统的缓存上。日志仍然会每秒刷新到磁盘中去，因此通常不会丢失每秒1-
　　2次更新的消耗。如果设置为 0 就快很多了，不过也相对不安全了 -- MySQL服务器崩溃时
　　就会丢失一些事务。设置为 2 指挥丢失刷新到操作系统缓存的那部分事务。

　　table_cache -- 打开一个表的开销可能很大。例如MyISAM把MYI文件头标志该表正在使用
　　中。你肯定不希望这种操作太频繁，所以通常要加大缓存数量，使得足以最大限度地缓存打
　　开的表。它需要用到操作系统的资源以及内存，对当前的硬件配置来说当然不是什么问题了。
　　如果你有200多个表的话，那么设置为 1024 也许比较合适（每个线程都需要打开表），
　　如果连接数比较大那么就加大它的值。我曾经见过设置为 100,000 的情况。

　　thread_cache -- 线程的创建和销毁的开销可能很大，因为每个线程的连接/断开都需要。
　　我通常至少设置为 16。如果应用程序中有大量的跳跃并发连接并且 Threads_Created 的值
　　也比较大，那么我就会加大它的值。它的目的是在通常的操作中无需创建新线程。
　　query_cache -- 如果你的应用程序有大量读，而且没有应用程序级别的缓存，那么这很有
　　用。不要把它设置太大了，因为想要维护它也需要不少开销，这会导致MySQL变慢。通常设置
　　为 32-512Mb。设置完之后最好是跟踪一段时间，查看是否运行良好。在一定的负载压力下，
　　如果缓存命中率太低了，就启用它。

　　sort_buffer_size --如果你只有一些简单的查询，那么就无需增加它的值了，尽管你有
　　64GB 的内存。搞不好也许会降低性能
								



								</pre>
							</code>
						</div>
						
				    </div>
				</div>
				<!-- <div class="col-md-4"> 

						dddd
				</div> -->
				<div class="col-md-4 column">
					<h3>博文链接</h3>
					<ul>
						<li>
							<a href="./b.html" target="#name1"> 面相对象的优缺点</a>
						</li>
						<li>
							<a href="./a.html">svn和git  谁更好用</a>
						</li>
						<li>
							<a href="./master.html"></a>
						</li>
						<li>
							<a href="./phpbase.html"></a>
						</li>
					</ul>
				</div>
			</div>
		</div>
	

	</body>
</html>
